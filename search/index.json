[{"content":" Happy Saturday! Welcome back to another blog post. In this edition, we\u0026rsquo;ll be taking a short break from OneDrive to have a quick dive into managing applications using the command line tool winget - Microsoft\u0026rsquo;s \u0026ldquo;Client Interface to the Windows Package Manager service\u0026rdquo;.\nIf you\u0026rsquo;re looking for another way to install, update, and uninstall software on Windows, you\u0026rsquo;re in the right place. Let\u0026rsquo;s get started!\nChecking if Winget is Installed Winget is supported on Windows 10 1709 (build 16299) or later. Before we jump in, let\u0026rsquo;s make sure it\u0026rsquo;s installed in your environment. You can easily check by opening your command prompt or PowerShell and typing the following:\n1 winget --help or\n1 winget -? If Winget is installed, you\u0026rsquo;ll see a helpful command summary along with various options and commands that you can use.\nAn important note from Microsoft on this: The winget tool will not be available until you have logged into Windows as a user for the first time, triggering Microsoft Store to register Windows Package Manager as part of an asynchronous process. If you have recently logged in as a user for the first time and find that winget is not yet available, you can open PowerShell and enter the following command to request this winget registration: Add-AppxPackage -RegisterByFamilyName -MainPackage Microsoft.DesktopAppInstaller_8wekyb3d8bbwe\nInstalling the Latest Version of Winget If you\u0026rsquo;re missing Winget or want to ensure you have the latest version, you can install it using the following command from Microsoft:\n1 2 3 4 5 6 7 8 $progressPreference = \u0026#39;silentlyContinue\u0026#39; Write-Information \u0026#34;Downloading WinGet and its dependencies...\u0026#34; Invoke-WebRequest -Uri https://aka.ms/getwinget -OutFile Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle Invoke-WebRequest -Uri https://aka.ms/Microsoft.VCLibs.x64.14.00.Desktop.appx -OutFile Microsoft.VCLibs.x64.14.00.Desktop.appx Invoke-WebRequest -Uri https://github.com/microsoft/microsoft-ui-xaml/releases/download/v2.7.3/Microsoft.UI.Xaml.2.7.x64.appx -OutFile Microsoft.UI.Xaml.2.7.x64.appx Add-AppxPackage Microsoft.VCLibs.x64.14.00.Desktop.appx Add-AppxPackage Microsoft.UI.Xaml.2.7.x64.appx Add-AppxPackage Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle You could also install \u0026ldquo;App Installer\u0026rdquo; through the Microsoft Store to get to the same outcome.\nNavigating Available Command Line Options Winget offers an array of powerful command-line options that enable you to perform various tasks. To explore them in detail, you can use the following command:\n1 winget -? This will provide you with a handy list of commands, Each with their own context relevant options:\nTo get more details on any specific commands available options, pass them the help argument. [-?]\nfor example, winget install -? would return the relevant options realating to installation. Some of these that are going to be relevant to us shortly are:\nInstall Option Description \u0026ndash;id Filter results by id \u0026ndash;name Filter results by name -h,\u0026ndash;silent Request silent installation \u0026ndash;accept-package-agreements Accept all licenseagreements for packages \u0026ndash;disable-interactivity Disable interactive prompts Searching for Packages Finding packages with Winget is simple. If you\u0026rsquo;re looking for, let\u0026rsquo;s say, Google Chrome, you can use the following command:\n1 winget search Chrome This will present you with a list of matching packages, along with their IDs, versions, and sources.\nGetting Package Information Curious about the details of a specific package? You can use the show command to retrieve comprehensive information. For instance, to get details about Google Chrome, you can use:\n1 winget show --id Google.Chrome It\u0026rsquo;s a good idea to use the \u0026lsquo;Show\u0026rsquo; command to verify the package you are interacting with, is what you think it is.\nSilently Installing a Package Sometimes you might want to install packages without any prompts. To do so, use the --silent flag. For example:\n1 winget install --id Google.Chrome --silent Silently Upgrading All Packages To keep your applications up to date without manual intervention, use the upgrade command with the following options:\n1 winget upgrade --all --uninstall-previous --force --accept-package-agreements --accept-source-agreements --silent --disable-interactivity Scripting winget Microsoft provides an Example Bash script that can install packages one after another using Winget.\n1 2 3 4 5 6 7 8 @echo off Echo Install Powertoys and Terminal REM Powertoys winget install Microsoft.Powertoys if %ERRORLEVEL% EQU 0 Echo Powertoys installed successfully. REM Terminal winget install Microsoft.WindowsTerminal if %ERRORLEVEL% EQU 0 Echo Terminal installed successfully. %ERRORLEVEL% An important note from Microsoft on this: When scripted, winget will launch the applications in the specified order. When an installer returns success or failure, winget will launch the next installer. If an installer launches another process, it is possible that it will return to winget prematurely. This will cause winget to install the next installer before the previous installer has completed.\nSilently Installing Multiple Specific Packages (One Liner) If you want to automate the installation of a specific set of packages, you can use a script like this:\n1 winget install --id \u0026#34;7zip.7zip\u0026#34; \u0026#34;Adobe.Acrobat.Reader.64-bit\u0026#34; \u0026#34;Zoom.Zoom\u0026#34; \u0026#34;Notepad++.Notepad++\u0026#34; \u0026#34;Google.Chrome\u0026#34; \u0026#34;Mozilla.Firefox\u0026#34; \u0026#34;VideoLAN.VLC\u0026#34; \u0026#34;Egnyte.EgnyteDesktopApp\u0026#34; --silent --disable-interactivity --accept-source-agreements --accept-package-agreements Listing Installed Packages You can get a list of installed packages using the command:\n1 winget list This command will output a table of installed packages and properties such as Name, Id, Version \u0026amp; Available Source.\nInterestingly, this command will even display packages that were not originally installed through Windows Package Manager.\nSilently Uninstalling a Package Removing packages silently is just as easy. For example, to silently uninstall Google Chrome:\n1 winget uninstall --id Google.Chrome --silent With these Winget commands and techniques, you have the power to manage your applications using Microsofts own package manager.\nThat\u0026rsquo;s it for today! I hope this quick dive into managing applications with Winget proves helpful. Until next time, happy coding and exploring! ðŸš€\nAutomate and script away - Happy Shellcode Saturday! ","date":"2023-08-19T06:45:00+01:00","image":"https://www.shellcodesaturdays.co.uk/post/Getting-To-Know-Winget/Winget-Help.PNG","permalink":"https://www.shellcodesaturdays.co.uk/p/quick-dive-managing-applications-with-winget/","title":"Quick Dive: Managing Applications With Winget"},{"content":"Managing OneDrive: Converting Files to Online-Only with PowerShell 28/06/2024 - 23.34 | Edit: Some of the information provided here is not fully comlpete. Further research has been done and an update is coming soon!\nHello there, another quick one to finish off the day. Let\u0026rsquo;s dive into a quick breakdown of a useful little PowerShell script we stumbled upon in Tristan Tyson\u0026rsquo;s tech blog whilst looking into Getting OneDrive File States with PowerShell. This small but handy script is all about converting your OneDrive (Commercial) files into online-only mode. This can be scoped for OneDrive (Personal) files as well.\nThis simple little script could be used to change the attribute of OneDrive files to \u0026lsquo;Cloud Only\u0026rsquo;, which would free up available disk space as any locally synced files are uploaded to OneDrive.\nLet\u0026rsquo;s break it down step by step.\nThe Script: Streamlining Online-Only Conversion The script focuses on using PowerShell to set your OneDrive (Commercial) files as online-only, saving local storage. You can check out the original post here, courtesy of Tristan Tyson.\nHere\u0026rsquo;s the script laid out for you:\n1 2 3 4 5 get-childitem $ENV:OneDriveCommercial -Force -File -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Attributes -match \u0026#39;ReparsePoint\u0026#39; -or $_.Attributes -eq \u0026#39;525344\u0026#39; } | ForEach-Object { attrib.exe $_.fullname +U -P /s } The Breakdown: What Each Part Does Gathering OneDrive Files: We start by using Get-ChildItem to get the OneDrive directory contents (recursively). The -File switch ensures we focus on files, and -Recurse dives into subdirectories.\nChoosing the Right Ones: With Where-Object, we pick files with specific attributes. Those with \u0026lsquo;ReparsePoint\u0026rsquo; or \u0026lsquo;525344\u0026rsquo; attributes are targeted as these attributes relate to locally availabile files (See my previous post: Getting OneDrive File States with PowerShell).\nMaking the Change: For each chosen file, we employ attrib.exe to do the magic. The +U -P /s commands shift the file to online-only mode.\nEmbrace Streamlined OneDrive Management And there you have it, folks! A straightforward dive into Tristan Tyson\u0026rsquo;s script for transforming OneDrive files into online-only mode. With a few lines of PowerShell, you can streamline your file management, making the most of online storage.\nFeel free to use this script to optimize your OneDrive experience. Here\u0026rsquo;s to more efficient digital spaces and simplified file management!\nWith this script in your toolkit, you\u0026rsquo;ve got the power to make your OneDrive files online-only and keep things tidy. Stay tuned for more useful script breakdowns and tips!\nNext time: We will look at creating a dashboard alert and automated remediation task for use with RMM software. This will likely utilise elements of or even combine this small script we haev created today and our previous script to Get OneDrive File Sync Status Automate and script away - Happy Shellcode Saturday! ","date":"2023-08-12T23:45:00+01:00","image":"https://www.shellcodesaturdays.co.uk/post/Convert-OneDrive-Files-Online-Only/OneDriveBanner-White.png","permalink":"https://www.shellcodesaturdays.co.uk/p/deconstructed-convert-onedrive-files-to-online-only/","title":"Deconstructed: Convert OneDrive Files to Online-Only"},{"content":"Navigating the World of OneDrive File Attributes In our ever-connected digital landscape, OneDrive has remained a prominent player in the realm of cloud storage and collaboration. Managing files and syncing them across devices is generally effortless, but have you ever wondered about the nitty-gritty details of how OneDrive handles these files locally? Today, we\u0026rsquo;ll unveil the magic of PowerShell and explore how to retrieve and interpret the attributes of local OneDrive files, specifically focusing on their File On Demand (FOD) states.\nBeggining Our Quest My journey began with a simple yet intriguing task: I wanted to create a script that could examine local OneDrive files and extract their attributes, particularly shedding light on their FOD states. After some exploration, I stumbled upon a reference script from Tristan Tyson\u0026rsquo;s tech blog that seemed promising.\nThe initial script was straightforward:\n1 2 3 4 get-childitem | ForEach-Object { write-host \u0026#34;$_ :\u0026#34; $_.Attributes } This script looped through files and displayed their attributes. However, to adapt it for my needs, I needed to focus on OneDrive\u0026rsquo;s specific attributes.\nThe Reference Table and Adjustments The reference script came with a table that associated attribute values with file states:\nFile State Attribute Cloud-Only 5248544 Always available 525344 Locally Available ReparsePoint However, during my testing phase, I realized that the provided values didn\u0026rsquo;t correctly align with OneDrive\u0026rsquo;s attributes on my machine.\nI desperately scoured the archives in search of any mention of the elusive attributes but alas, I came up short in this endeavor. So, I rolled up my sleeves and manually tested different sync states to identify the correct attribute values and their corresponding human-readable states.\nFor testing (and ultimately my end goal), I took the reference script and adjusted it to drill down to the current users OneDrive (Commercial) directory. This allowed me (with toggling sync states multiple times) to identify the different attributes assiociated with different states.\n1 2 3 4 get-childitem $ENV:OneDriveCommercial -Force -File -Recurse | ForEach-Object { write-host \u0026#34;$_ :\u0026#34; $_.Attributes } Armed with the information gathered in the testing phase, I then constructed my own reference table.\nFile State Attribute Cloud-Only 5248544 Always available 525344 Downloading 4724256 Uploading 1049632 Locally Available Archive, ReparsePoint Hidden System File 1572902 There might be additional attributes I didn\u0026rsquo;t come across during my testing phase. I\u0026rsquo;ll keep exploring and updating the reference table here whenever I spot them. For now, I deemed the collected data sufficient to make sense of the attribute values in a way that humans can understand.\nCracking the Code: The Finished Script After traveling so far on this quest, the elements of the script emerged, ready to unveil the OneDrive attributes we sought. To that end, I focused on generating clear and comprehensible results into a table format, leveraging a switch statement and PSCustomObject to complete this final task.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $OneDrivePath = $ENV:OneDriveCommercial $filesInfo = Get-ChildItem $OneDrivePath -Force -File -Recurse | ForEach-Object { $fileName = $_.Name $attributes = $_.Attributes $state = switch ($attributes) { 5248544 { \u0026#34;Cloud-Only\u0026#34; } 525344 { \u0026#34;Always Available\u0026#34; } 4724256 { \u0026#34;Downloading\u0026#34; } 1049632 { \u0026#34;Uploading\u0026#34; } 1572902 { \u0026#34;Hidden System File\u0026#34; } \u0026#34;Archive, ReparsePoint\u0026#34; { \u0026#34;Locally Available\u0026#34; } default { \u0026#34;Unknown\u0026#34; } } [PSCustomObject]@{ FileName = $fileName State = $state } } $filesInfo | Format-Table -AutoSize -Wrap The script was then tested for its efficiency at gathering the needed information.\nWith this final script, I was able to successfully list the OneDrive file attributes as desired. The script translates OneDrive file attribute values into human-readable states, making it easier than ever to understand the synchronization status of each file.\nFinal Thoughts and Further Explorations In this exhilarating journey, we ventured into the realm of PowerShell to reveal the attributes of local OneDrive files. Armed with a script that interprets File On Demand states, we\u0026rsquo;ve unlocked a deeper understanding of file synchronization. As we continue our IT expeditions, let\u0026rsquo;s remain curious and ever-ready to explore the intricacies of our digital world.\nNext time: We will look at setting the sync state of OneDrive files to \u0026ldquo;Online-Only\u0026rdquo; leveraging their file attributes to do so. Automate and script away - Happy Shellcode Saturday! ","date":"2023-08-12T04:45:00+01:00","image":"https://www.shellcodesaturdays.co.uk/post/Get-OneDrive-Sync-Status-Script/onedrive-logo-banner.png","permalink":"https://www.shellcodesaturdays.co.uk/p/getting-onedrive-file-states-with-powershell/","title":"Getting OneDrive File States with PowerShell"},{"content":"So, lets start checking off some of the goals outlined in my previous post\u0026hellip; At the MSP where I work, we configure a fair amount of Windows computers (like many others in the industry).\nI have already created a configuration script that does most of the heavy lifting. This script is due a massive overhaul but this can wait. For now, I need to create a function that sets the background wallpaper and lockscreen images for all users.\nPreviously when I have looked into this, I have come across \u0026lsquo;Personalization CSP\u0026rsquo; in Microsoft documentation but hit a roadblock when i found that this was restricted to Education and Enterprise SKUs only.\nI recently saw in a post on Reddit (I dont remember what post but if i find it i will link here) that this is no longer the case. Looking at the documentation here: Microsoft - Personalisation CSP, the post was correct.\nLets get started then\u0026hellip; Unfortunately, this documentation does not include any reference on application via registry but luckily, a quick Google search tells me what keys and values will be needed. So thats half the battle done.\nFirst off, we need to create the following registry key: \u0026quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PersonalizationCSP\u0026quot;\n1 2 # Create PersonalizationCSP Registry Key New-Item HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PersonalizationCSP -Force Next, we\u0026rsquo;ll need to declare some variables to contain the registry key path and image files.\n1 2 3 4 # Declare Variables $RegPath = \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PersonalizationCSP\u0026#34; $BackgroundImage = \u0026#34;C:\\Images\\Background.png\u0026#34; $LockScreenImage = \u0026#34;C:\\Images\\Background.png\u0026#34; Now, we can set the registry key values. We\u0026rsquo;ll start with the lockscreen values.\n1 2 3 4 # Set Lockscreen Registry Keys New-ItemProperty -Path $RegPath -Name LockScreenImagePath -Value $LockScreenImage -PropertyType String -Force | Out-Null New-ItemProperty -Path $RegPath -Name LockScreenImageUrl -Value $LockScreenImage -PropertyType String -Force | Out-Null New-ItemProperty -Path $RegPath -Name LockScreenImageStatus -Value 1 -PropertyType DWORD -Force | Out-Null And finally, the desktop background image values.\n1 2 3 4 #Background Wallpaper Registry Keys New-ItemProperty -Path $RegPath -Name DesktopImagePath -Value $Backgroundimage -PropertyType String -Force | Out-Null New-ItemProperty -Path $RegPath -Name DesktopImageUrl -Value $Backgroundimage -PropertyType String -Force | Out-Null New-ItemProperty -Path $RegPath -Name DesktopImageStatus -Value 1 -PropertyType DWORD -Force | Out-Null To finish this up, we can bundle all these components together to form a simple function that we can implement in the configuration script mentioned earlier.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function Set-CorporateLockScreen{ # Create PersonalizationCSP Registry Key New-Item HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PersonalizationCSP -Force # Declare Variables $RegPath = \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PersonalizationCSP\u0026#34; $BackgroundImage = \u0026#34;C:\\Images\\Background.png\u0026#34; $LockScreenImage = \u0026#34;C:\\Images\\Background.png\u0026#34; # Set Lockscreen Registry Keys New-ItemProperty -Path $RegPath -Name LockScreenImagePath -Value $LockScreenImage -PropertyType String -Force | Out-Null New-ItemProperty -Path $RegPath -Name LockScreenImageUrl -Value $LockScreenImage -PropertyType String -Force | Out-Null New-ItemProperty -Path $RegPath -Name LockScreenImageStatus -Value 1 -PropertyType DWORD -Force | Out-Null #Background Wallpaper Registry Keys New-ItemProperty -Path $RegPath -Name DesktopImagePath -Value $Backgroundimage -PropertyType String -Force | Out-Null New-ItemProperty -Path $RegPath -Name DesktopImageUrl -Value $Backgroundimage -PropertyType String -Force | Out-Null New-ItemProperty -Path $RegPath -Name DesktopImageStatus -Value 1 -PropertyType DWORD -Force | Out-Null } Calling this function in a test environment and then restarting the endpoint, I can see the specified images have been applied as the background wallpaper \u0026amp; lockscreen as desired.\nThis does prevent standard users from changing their background and lockscreens, so i may look for a less restrictive way to achieve this but for now, this\u0026rsquo;ll do.\nEasy enough, lets go for bonus points\u0026hellip; To save from having to name our image files a generic name for all our clients, it would be helpfult to be able to declare the image \u0026ldquo;On the fly\u0026rdquo;. If this can be achieved with a familiar file explorer \u0026ldquo;Browse\u0026rdquo; window, even better.\nBack to Google I go.\nAgain, after a short search I came across an article that appears to fit the bill: 4Sysops - How to create an open file dialog with PowerShell\nSo according to the article, to start off, we will need to load the System.Windows.Forms assembly.\n1 2 # Load the System.Windows.Forms assembly Add-Type -AssemblyName System.Windows.Forms Next, we will create a Open File Dialog instance.\n1 2 # Instantiate an OpenFileDialog object using New-Object. $FileBrowser = New-Object System.Windows.Forms.OpenFileDialog -Property @{ InitialDirectory = \u0026#34;C:\\\u0026#34; } If we want, we can even restrict the file type that can be selected.\n1 2 3 4 $FileBrowser = New-Object System.Windows.Forms.OpenFileDialog -Property @{ InitialDirectory = [Environment]::GetFolderPath(\u0026#39;Desktop\u0026#39;) Filter = \u0026#39;Documents (*.docx)|*.docx|SpreadSheet (*.xlsx)|*.xlsx\u0026#39; } To be more appropriate to our needs, lets filter to images instead.\n1 2 3 4 $FileBrowser = New-Object System.Windows.Forms.OpenFileDialog -Property @{ InitialDirectory = [Environment]::GetFolderPath(\u0026#39;Desktop\u0026#39;) Filter = \u0026#39;Images (*.jpg;*.jpeg;*.png;*.bmp)|*.jpg;*.jpeg;*.png;*.bmp\u0026#39; } Finally, we just need to display the dialog instance.\n1 2 # Display the Browse dialog $null = $FileBrowser.ShowDialog() We can then, yet again wrap this into a simple function which can be implemented into scripts as needed.\n1 2 3 4 5 6 7 8 9 function Get-OpenFileDialog{ # Load the System.Windows.Forms assembly Add-Type -AssemblyName System.Windows.Forms # Instantiate an OpenFileDialog object using New-Object. $FileBrowser = New-Object System.Windows.Forms.OpenFileDialog -Property @{ InitialDirectory = \u0026#34;C:\\\u0026#34; } # Display the Browse dialog $null = $FileBrowser.ShowDialog() $SelectedFile = ($FileBrowser.FileName) } And there we have it. When this is ran, the familiar browse or open dialog is produced. A file can then be selected, which will be stored in OpenFileDialog.\nIf we piece these two functions together, we have a working solution for deploying corporate lock screen and desktop images, which we can implement into our main Windows configuration script.\nSomething like this should do\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 function Get-OpenFileDialog{ # Load the System.Windows.Forms assembly. Add-Type -AssemblyName System.Windows.Forms # Instantiate an OpenFileDialog object using New-Object. $FileBrowser = New-Object System.Windows.Forms.OpenFileDialog -Property @{ InitialDirectory = \u0026#34;C:\\\u0026#34; Filter = \u0026#39;Images (*.jpg;*.jpeg;*.png;*.bmp)|*.jpg;*.jpeg;*.png;*.bmp\u0026#39; } # Display the Browse dialog. $null = $FileBrowser.ShowDialog() $SelectedFile = ($FileBrowser.FileName) $SelectedFile } function Set-CorporateLockScreen{ # Create PersonalizationCSP Registry Key. New-Item HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PersonalizationCSP -Force | Out-Null # Declare Variables. $RegPath = \u0026#34;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\PersonalizationCSP\u0026#34; Write-Host \u0026#34;Please Select an Image File for the Background Image.\u0026#34; $BackgroundImage = (Get-OpenFileDialog) Write-Host \u0026#34;Please Select an Image File for the Lockscreen Image.\u0026#34; $LockScreenImage = (Get-OpenFileDialog) # Set Lockscreen Registry Keys New-ItemProperty -Path $RegPath -Name LockScreenImagePath -Value $LockScreenImage -PropertyType String -Force | Out-Null New-ItemProperty -Path $RegPath -Name LockScreenImageUrl -Value $LockScreenImage -PropertyType String -Force | Out-Null New-ItemProperty -Path $RegPath -Name LockScreenImageStatus -Value 1 -PropertyType DWORD -Force | Out-Null #Background Wallpaper Registry Keys New-ItemProperty -Path $RegPath -Name DesktopImagePath -Value $Backgroundimage -PropertyType String -Force | Out-Null New-ItemProperty -Path $RegPath -Name DesktopImageUrl -Value $Backgroundimage -PropertyType String -Force | Out-Null New-ItemProperty -Path $RegPath -Name DesktopImageStatus -Value 1 -PropertyType DWORD -Force | Out-Null } After adding this to our main configuration script, we can call the function Set-CorporateLockScreen in the execution section. We will then be prompted to select the files for the lockscreen and background and finally the registry keys will be applied.\nPart of the standard workflow (when using the script I created some time ago) is already to restart the endpoint manualy upon script completion. As such, we do not need to consider this in these functions. If we were implementing these functions elsewhere, a system restart would need to be factored in.\nAutomate and script away - Happy Shellcode Saturday! ","date":"2023-04-22T14:03:47+01:00","image":"https://www.shellcodesaturdays.co.uk/post/Corporate-Lockscreen-Deployment-Script/MicrosoftPowershell_.PNG","permalink":"https://www.shellcodesaturdays.co.uk/p/corporate-lockscreen-deployment/","title":"Corporate Lockscreen Deployment"},{"content":"Hello World, Today, I launch my new blog using Github Pages, Hugo Go and the theme: Stack by CaiJimmy. I previously tested manually deploying a blog using the dot-hugo theme from Themefisher which worked great at the time, but for reasons unknown to me, when i attempted to deploy for real, i experienced some critical issues. So after giving it a break and returning the following day, I started afresh, searched for a new theme and came across Stack. So here we are.\nMoving on\u0026hellip; So, a little about me. I am a IT technician and technology enthusiast. I have been working in the Managed Service Provider space for a little over 6 years. We support businesses from a range of sectors and each have their own nuances and specific requirements.\nLike all forward thinking technicians should, wherever i see a repeated task, i like to see if i can automate it (Ususally via PowerShell). Thats one of the purposes of this blog. Somewhere that i can document any of the knowledge i aquire along my way and share any helpful automations i may create or find.\nI used to be a Linux guy and my initial years were spent on Arch/Fedora/Whaterver flavor i chose that at that time. Since working in the MSP space, i have been soley using Windows.\nThe main purpose of this blog is to follow along on my journey as an IT Technician, gaining knowledge on any areas of IT which serve my purpose, including but not limited to: Scripting/Automation, Microsoft 365 Administration, Networking, SecOps, OSINT etc.\nFor more information about the theme used in this blog, check the documentation: Stack - Designed for bloggers\nPhoto by Prawny on Jooinn\n","date":"2023-04-15T17:24:33Z","image":"https://www.shellcodesaturdays.co.uk/p/hello-world/EarthBanner_hu15165171055242903098.jpeg","permalink":"https://www.shellcodesaturdays.co.uk/p/hello-world/","title":"Hello World"}]